/*

Baekjoon 24313 - 알고리즘 수업 - 점근적 표기 1

https://www.acmicpc.net/problem/24313




2025-04-18 첫번째 접근

O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다}

말뜻이 이해가 안가 계속 읽었다..

즉

f(n)이 =a1n + a0 라 할떄

a1 = 7 a0 = 7 이고

c 가 10,

그리고 n 이 1 이라면

n >=1 인 모든 n은


7n + 7 <= 10n 을 만족 하는지를 검사하라는 프로그래밍이다..

그런데... 이게 시간복잡도 문제인가..?

-두번째 접근-


0으로는 나눌수 없으니까 0에 대한 예외 처리를 해주어야한다!

 추가 : 상수가 n의 계수가 같고 상수가 음수이면 어떤수가 오든 참이므로 1이 출력되야한다.!


 -세번째 접근-


 if ((c - a1) == 0) {
		if (a0 <= 0) {
			cout << 1;
		}
		else {
			cout << 0;
			}
		}
	else {
		if ((a0 / (c - a1)) <= n0) {
			cout << 1;
		}
		else {
			cout << 0;
		}
	}

	음수로 나눌때는 부등호가 바뀌어야 된다는 사실을 까먹었다..


	네번째 접근-

	완전히 틀렸다. 부등호 계산이 성립하는 선결 조건을 무시한채 진행했더니 이런 결과가..
	그리고 그냥 단순히 대입하면되는데 왜 돌아갔지? 너무 어렵게만 생각하는게 내 단점인듯 하다.
	앞으로 조금씩 단순하게 생각하는걸 목표로 하자..

	그래프로 접근하면 이해가 쉽다..
	1차 그래프로 생각하면
	a1이 음수가 되면 a1은 기울기를 의미하는데 a1이 c를 넘는 순간 만족하는 조건이 전혀 없다.
	그래프를 생각하면 이해가 쉬운 문제였다.
*/

#include <iostream>

using namespace std;

int main() {
	int a1, a0;
	cin >> a1 >> a0;
	int c;
	cin >> c;
	int n0;
	cin >> n0;

	if ((a1*n0 + a0 <= c * n0) && a1 <= c) {
		cout << 1;
	}
	else{ 
		cout << 0;
	}
}

